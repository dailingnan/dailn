---
title: 啃透Java并发之synchronized篇
date: 2019-01-06 17:13:43
categories: "Java并发编程"
tags: [Java,并发,多线程]
---

<Excerpt in index | 首页摘要> 

# 场景

​	在多线程并发编程中synchronized一直是元老级角色，作为最基本的互斥手段，很多人都会称呼它为重量级锁。

<!-- more -->
<The rest of contents | 余下全文>

​	但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。	

# 三种形式

​	先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 SE 1.6对synchronized进行了**各种优化**之后，有些情况下它就**并不那么重**了。Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。

1. 对于普通同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前类的Class对象。
3. 对于同步方法块，锁是Synchonized括号里配置的对象。

# 实现原理

​	synchronized关键字经过编译之后，会在同步块的前后分别形成**monitorenter**和**monitorexit**这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

​	monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个**monitor**与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

​    在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是**可重入**的，不会出现自己把自己锁死的问题。重入是通过锁的计数器来判断的，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。

# synchronized  1.5与1.6优化后比较

​	在1.5引入重入锁后（ReentratLock），synchronized与之比较尤为显得相对重量级。synchronized在1.5之前是通过阻塞实现同步，每次必须获得锁然后执行操作，执行完毕释放锁。Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态**、**偏向锁状态**、**轻量级锁状态**和**重量级锁**状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种**锁升级却不能降级**的策略，目的是为了提高获得锁和释放锁的效率。

以下是通过跟ReentratLock对比，来体现synchrlnized优化后的效率提升。

![](https://note.youdao.com/yws/api/personal/file/F3FCF06284A546319B2A221C849D8160?method=download&shareKey=535b51a38fc4d87ad186508d41acecba)

### java对象头

​	 synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。具体如下图

![](https://note.youdao.com/yws/api/personal/file/B5E03AFB41984EF6B6ED82EE7858CADA?method=download&shareKey=fb8e75d236242d46a6862f51fa1f61ec)

 java对象头的存取结构

![](https://note.youdao.com/yws/api/personal/file/FD9FC2F7B51D4F7FA65B6A04092A13CD?method=download&shareKey=acbd42755e2c33097fc0874e0285a21d)

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据。

![](https://note.youdao.com/yws/api/personal/file/CA427DB098FC4FE2B82B5428A9B4DBE0?method=download&shareKey=4216427949f86592255052be40e66816)

### 自旋锁

​	互斥同步对性能最大的影响是阻塞的实现，在多线程程序中，当线程调度临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文切换操作，这种操作带来极大的开销（挂起线程和恢复线程都需要转入内核态中完成），保存和恢复上下文，丢失局部性，并且cpu时间将更多地花在线程调度而不是线程运行上面。

 	虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

​	 自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。

### 自适应自旋锁

​	自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。

### 偏向锁

​	锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark。

偏向锁的撤销：

​	偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark。



![](https://note.youdao.com/yws/api/personal/file/3008F51EE46C4F99B97F682415882E8B?method=download&shareKey=62f1b3f290919d0fd0ad53b150d311cb)

偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。

### 轻量级锁

#### 轻量级锁加锁

 	线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

#### 轻量级锁解锁

​	Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。

![](https://note.youdao.com/yws/api/personal/file/9D14CE5A77DE4AFD86CF02066EB4C2CD?method=download&shareKey=fc0059533f96bdf61bfbabb68a1d1174)

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 补充

1. 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
2. 轻量级在升级成重量级锁之前会先进行一定的自旋（自适应自旋），自旋拿到锁了就能避免线程上下文切换带来的额外开销。但是在一定次数的自旋还没拿到锁就会升级成重量级锁，后续线程堵塞。直到持有锁的线程释放锁唤醒其他线程，被唤醒的线程开启新的夺锁之争。

### 锁的优缺点对比

![](https://note.youdao.com/yws/api/personal/file/49197DF4552F4F71925C170CF20722AA?method=download&shareKey=f9673a97f495f7a06201dba8447111d6)

# 总结

​	看完上面各种锁的区别，现在应该可以理解为什么锁只能升级不能降级了（偏向锁状态可以被重置为无锁状态。），各种锁都有各种锁的应用场景，虽然实际场景中不用我们控制，但是理解synchronized的实现原理，对我们实际的开发也是有很大帮助的。